<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>forma</title>

		<meta name="description" content="Forest Monitoring">
		<meta name="author" content="Dan Hammer">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

	</head>

	<body>

		<div class="reveal">

			<div class="slides">

				<section>
					<h1>FORMA</h1>
					<h3>Forest Monitoring in Clojure</h3>
					<p>
						<small>Dan Hammer // <a href="http://twitter.com/econohammer">@econohammer</a></small>
					</p>
				</section>

            <!-- Clojure supported this openness. -->

            <!-- It was also the right tool, the natural tool for other reasons -->

            <!-- I intend to show features of the FORMA processing
            that illustrate why Clojure is particularly suitable for
            the steps -->

            <!-- Mapping across subblocks.  Map acros partitions, and
            then reduce over the time dependent characteristics for a
            single attribute to represent the dynamic attributes of
            the time-series -->

            <!-- splitting processing up by parameter vector (to search for -->
            <!-- good parameters) or by NDVI time series to extract the -->
            <!-- characteristics -->

            <!-- collect the characteristics by ecoregion to compare them -->

            <!-- Deforestation is a problem -->
				<section>

				  <section>
					 <h2>Deforestation accounts for 12% of annual greenhouse gas emissions</h2>
				  </section>

				  <section data-state="alert">
					 <h2>Deforestation is accelerating</h2>
                <img width="1000" height="400" src="total-defor.png" alt="rate">
				  </section>

				  <section data-state="alert">
					 <h2>... and dispersing</h2>
                <img width="1000" height="400" src="entropy.png" alt="entropy">
				  </section>

				  <section>
					 <h2>Any viable effort to curb deforestation rates will rely on open information</h2>
				  </section>

				</section>

            <!-- Global forest watch website -->
            <section>

				  <section>
                <img width="900" height="650" src="http://i.imgur.com/u6TJA.png" alt="gfw">
				  </section>

              <section>
                <h1>Everything</h1>
                <h3 style="color:#33CCFF">from raw data to analysis to mapping to website</h3>
                <h1>is open source</h1>
              </section>

            </section>                 


            <section>            

              <!-- Features of the system -->
              <section>
                <h2>Features of the FORMA data</h2>
                <ol>
					   <li class="fragment">Pan-tropical (58 countries)</li> <br>
					   <li class="fragment">500m resolution (2 billion pixels)</li> <br>
					   <li class="fragment">16-day updates (271 through Dec. 2012)</li> <br>
				    </ol>
              </section>

              <!-- Data description -->
              <section>
                <h2>Data sources</h2>
                <ol>
					   <li class="fragment">Spectral data from MODIS sensor</li> <br>
					   <li class="fragment">Precipitation data from NOAA</li> <br>
					   <li class="fragment">Thermal anomalies from UMD</li> <br>
					   <li class="fragment">Ecoregions from WWF</li> <br>
                  <li class="fragment">Training deforestation data from SDSU</li> <br>
				    </ol>              
              </section>

            </section>

            <!-- Show that the partition framework to analyze the
            spectral time series is well-suited to Clojure -->
            <section>

              <section>
                <img width="1000" height="650" src="ndvi.png" alt="ndvi">
              </section>

              <section>
                <img width="1000" height="650" src="ndvi-breaks.png" alt="ndvi-break">
              </section>                                  

              <section>
                <img width="1000" height="650" src="ndvi-breaks2.png" alt="ndvi-break-2">
              </section>                                  

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
(require '[incanter.core :as i])

(defn trend-mat
  "returns a (T x 2) matrix with an intercept and linear progression."
  [T]
  (i/bind-columns (repeat T 1) (range T)))

(defn pseudoinverse
  "returns the pseudo-inverse of the supplied matrix `x` to be used in
  ordinary least squares regression."
  [x]
  (let [xt (i/trans x)]
    (i/mmult (i/solve (i/mmult xt x)) xt)))
			           </pre>
		            </code>
	             </p>
              </section>                 

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
(defn grab-trend
  "premultiplies the supplied time-series by the OLS trend
  pseudomatrix and returns the trend coefficient"
  [pseudo-mat ts]
  {:pre [= (count ts) (i/nrow pseudo-mat)]}
  (let [ts-mat (i/matrix ts)]
    (second (i/mmult pseudo-mat ts-mat))))

(defn windowed-trend
  "accepts the partition length and the full time series and returns a
  sequence of short-term linear trend coefficients."
  [block-len ts]
  (let [pseudo-mat (-> block-len trend-mat pseudoinverse)]
    (map (partial grab-trend pseudo-mat)
         (partition block-len 1 ts))))
			           </pre>
		            </code>
	             </p>
              </section>                 

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
(defn short-stat
  "returns the minimum (most negative) short term trend coefficients
  over the full time series."
  [block-param ts]
  (->> (windowed-trend block-param ts)
       (reduce min)))


(facts
  "demonstrate that short-stat reduces the dimension of the ndvi
  time series"
  (count ndvi) => 199
  (short-stat 24 ndvi) => -63.3346)
			           </pre>
		            </code>
	             </p>
              </section>                 

            </section>



            <!-- search for parameters in a distributed way -->
            <section>

              <section>
                <img width="650" height="650" src="raster1.png" alt="raster">
              </section>

              <section>
                <img width="650" height="650" src="raster2.png" alt="raster">
              </section>

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
(defn walk-matrix
  "Returns a sequence of matrices, after walking along the rows and
  columns of the given matrix a the specified window size and
  returning all window-by-window snapshots."
  [m window]
  (mapcat (comp (partial apply map vector)
                (partial map (partial partition window 1)))
          (partition window 1 m)))
			           </pre>
		            </code>
	             </p>
              </section>                 

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
      (def mat
        [[ 0    0    0    0    0    0    0    1    1     1 ]
         [ 0    0    0    1    0    0    0    0    0     1 ]
         [ 0    0    0    0    0    0    0    0    0     0 ]
         [ 0    0    0    0    0    0    0    0    0     0 ]
         [ 0    0    0    0    0    0    0    0    0     0 ]
         [ 0    0    0    0    0    0    0    1    1     0 ]
         [ 0    0    0    0    0    0    0    1    1     0 ]
         [ 1    0    0    0    0    0    0    1    0     0 ]
         [ 0    1    0    0    0    0    0    0    0     0 ]
         [ 1    1    0    0    0    0    0    0    0     0 ]])
			           </pre>
		            </code>
	             </p>
              </section>                 

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
(defn window-sum
  "sum the values of all pixels within supplied sub-window."
  [sub-mat]
  (reduce + (flatten sub-mat)))



(map window-sum
     (walk-matrix mat 3))
			           </pre>
		            </code>
	             </p>
              </section>                 

              <section>
                <img width="650" height="650" src="spatial-raw.png" alt="raster">
              </section>

              <section>
                <img width="650" height="650" src="spatial-smooth.png" alt="raster">
              </section>

            </section>


            <!-- map-reduce and find beta-vectorg -->
            <section>

              <section>
                <h1>Using Cascalog</h1>
                <h3 style="color:#33CCFF">to classify pixels based on time series attributes</h3>
                <h1>solved our problems</h1>                
              </section>

              <section>
	             <p align="left">
		            <code class="clojure">
			           <pre>
(defn beta-vector
  "returns the parameter vector for the logistic "
  [label-row feature-mat]
  (let [beta-init (repeat 0 (i/ncol feature-mat))]
    (loop [beta beta-init
           beta-diff 100]
      (if (< beta-diff 1e-8)
        (vec (.toArray beta))
        (let [update (beta-update beta label-row feature-mat rdg-cons)
              beta-new (.addRowVector beta update)
              diff (.distance2 beta beta-new)]
          (recur
           beta-new
           diff))))))
			           </pre>
		            </code>
	             </p>
              </section>                 

            </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>


